/*
	Handles reflection operations for a Coral type.

	Coral handles reflection operations for a #type through a _reflector_.
	Reflectors are automatically generated by the Coral compiler, so you
	don't have to write one unless you're working on something magic.

	All reflectors share this uniform interface, but only a subset of the
	methods are expected to be supported for a certain #type (depending on its
	kind). Please take notice of each method's exception specifications.

	Methods that receive values of type `any`---namely #getField, #setField
	and #invoke---can often handle type conversions. For example, #setField
	can receive a `double` and store it into a `string` field.
	The conversions are handled transparently by the `any` type---check
	its documentation for a list of supported conversions.

	Note that some lower-level methods are only available from C++.
	---
	tags: type-system
 */
interface IReflector
{
	// The type we are providing reflection for.
	readonly IType type;

	// Number of bytes occupied by instances of this type.
	readonly int32 size;

	/*
		Instantiates a component.

		Raises co.NotSupportedException if #type is not a co.IComponent.
	 */
	IObject newInstance() raises NotSupportedException;

	/*
		Creates a _dynamic proxy_ (of this #type) to the specified `provider`.

		A _dynamic proxy_ is a service that uses reflection to delegate all
		calls to a co.IDynamicServiceProvider. The proxy will always call
		co.IDynamicServiceProvider#dynamicRegisterService on the `provider`
		from within its constructor.

		Raises co.NotSupportedException if #type is not a co.IInterface.
		Raises co.IllegalArgumentException if `provider` is invalid (null).
	 */
	IService newDynamicProxy( in IDynamicServiceProvider provider )
		raises NotSupportedException, IllegalArgumentException;

	/*
		Gets the value of a `field` in `instance` and puts it into `var`.

		Raises co.NotSupportedException if #type is not a co.IRecordType.
		Raises co.IllegalArgumentException if `instance` is not of #type.
		Raises co.IllegalArgumentException if the `field` is not from #type.
		Raises co.IllegalStateException if `var` is not an output variable.
		Raises co.IllegalCastException if `var` cannot store the field value.
	 */
	void getField( in any instance, in IField field, in any var )
		raises NotSupportedException, IllegalArgumentException,
			IllegalStateException, IllegalCastException;

	/*
		Sets the value of a `field` in `instance` to `value`.

		Raises co.NotSupportedException if #type is not a co.IRecordType.
		Raises co.IllegalArgumentException if `instance` is not of #type.
		Raises co.IllegalArgumentException if the `field` is not from #type.
		Raises co.IllegalArgumentException if the `field` is _read-only_.
		Raises co.IllegalCastException if the field cannot store the `value`.
	 */
	void setField( in any instance, in IField field, in any value )
		raises NotSupportedException, IllegalArgumentException, IllegalCastException;

	/*
		Invokes a `method` from `instance`.

		Arguments are passed in `args` in direct order.
		Output parameters must be honored (by passing _out_ variables).
		Excess arguments are currently ignored.

		If the callee raises an exception, it will propagate unchanged;
		otherwise, whatever is returned is put into `retVal`.

		Raises co.NotSupportedException if #type is not a co.IClassType.
		Raises co.IllegalArgumentException if `instance` is not of #type.
		Raises co.IllegalArgumentException if the `method` is not from #type.
		Raises co.MissingInputException if `args` contains fewer arguments than the method expects.
		Raises co.IllegalStateException if an argument should be an _out_ variable but isn't.
		Raises co.IllegalCastException if an argument cannot be converted to the parameter type.
	 */
	void invoke( in any instance, in IMethod method, in any[] args, in any retVal )
		raises NotSupportedException, IllegalArgumentException,
			MissingInputException, IllegalStateException, IllegalCastException;

	/*
		Raises an exception (of this #type) with the given `message`.

		Raises co.NotSupportedException if #type is not an exception.
	 */
	void raise( in string message ) raises NotSupportedException;

	<c++
	/*
		Constructs an array of values in memory starting at `ptr`.
		The memory area should be at least `numValues * size` bytes long.
		Raises co.NotSupportedException if #type cannot be cast to a value.
	 */
	virtual void createValues( void* ptr, size_t numValues ) = 0;

	/*
		Copies the array of values at `fromPtr` to `toPtr`.
		Both arrays must contain `numValues` properly constructed values.
		Each copy is done using the value's assignment operator.
		Raises co.NotSupportedException if #type cannot be cast to a value.
	 */
	virtual void copyValues( const void* fromPtr, void* toPtr, size_t numValues ) = 0;

	/*
		Destructs an array of `numValues` values starting at `ptr`.
		All values must have been constructed with createValues().
		Raises co.NotSupportedException if #type cannot be cast to a value.
	 */
	virtual void destroyValues( void* ptr, size_t numValues ) = 0;

	/*
		Returns true if and only if a0 == b0, a1 == b1, ... aN == bN.
		Raises co.NotSupportedException if #type cannot be cast to a value.
	 */
	virtual bool compareValues( const void* a, const void* b, size_t numValues ) = 0;
	c++>
};
